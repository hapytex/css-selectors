-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compatibility package for the Foldable1 and Bifoldable1 type classes
--   
--   A compatibility package for the <tt>Foldable1</tt> and
--   <tt>Bifoldable1</tt> type classes, which were introduced in
--   <tt>base-4.18.0.0</tt> (GHC 9.6.1). For more information, see
--   &lt;<a>https://github.com/haskell/core-libraries-committee/issues/9</a>
--   this Core Libraries Committee proposal&gt;.
--   
--   <tt>Foldable1</tt> and <tt>Bifoldable1</tt> classify non-empty data
--   structures that can be folded to a summary value.
@package foldable1-classes-compat
@version 0.1

module Data.Bifoldable1
class Bifoldable t => Bifoldable1 t
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
instance Data.Bifoldable1.Bifoldable1 Data.Semigroup.Arg
instance Data.Bifoldable1.Bifoldable1 Data.Either.Either
instance Data.Bifoldable1.Bifoldable1 (,)
instance Data.Bifoldable1.Bifoldable1 ((,,) x)
instance Data.Bifoldable1.Bifoldable1 ((,,,) x y)
instance Data.Bifoldable1.Bifoldable1 ((,,,,) x y z)
instance Data.Bifoldable1.Bifoldable1 Data.Functor.Const.Const
instance Data.Bifoldable1.Bifoldable1 Data.Tagged.Tagged


-- | A class of non-empty data structures that can be folded to a summary
--   value.
module Data.Foldable1

-- | Non-empty data structures that can be folded.
class Foldable t => Foldable1 t

-- | Combine the elements of a structure using a semigroup.
fold1 :: (Foldable1 t, Semigroup m) => t m -> m

-- | Map each element of the structure to a semigroup, and combine the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1 Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | A variant of <a>foldMap1</a> that is strict in the accumulator.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1' Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1' :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | List of elements of a structure, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmpty (Identity 2)
--   2 :| []
--   </pre>
toNonEmpty :: Foldable1 t => t a -> NonEmpty a

-- | The largest element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; maximum (32 :| [64, 8, 128, 16])
--   128
--   </pre>
maximum :: (Foldable1 t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; minimum (32 :| [64, 8, 128, 16])
--   8
--   </pre>
minimum :: (Foldable1 t, Ord a) => t a -> a

-- | The first element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; head (1 :| [2, 3, 4])
--   1
--   </pre>
head :: Foldable1 t => t a -> a

-- | The last element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; last (1 :| [2, 3, 4])
--   4
--   </pre>
last :: Foldable1 t => t a -> a

-- | Generalized <a>foldr1</a>.
foldrMap1 :: Foldable1 t => (a -> b) -> (a -> b -> b) -> t a -> b

-- | Generalized <a>foldl1'</a>.
foldlMap1' :: Foldable1 t => (a -> b) -> (b -> a -> b) -> t a -> b

-- | Generalized <a>foldl1</a>.
foldlMap1 :: Foldable1 t => (a -> b) -> (b -> a -> b) -> t a -> b

-- | Generalized <a>foldr1'</a>.
foldrMap1' :: Foldable1 t => (a -> b) -> (a -> b -> b) -> t a -> b

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr1</a>, when applied to a binary
--   operator, and a list, reduces the list using the binary operator, from
--   right to left:
--   
--   <pre>
--   foldr1 f [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn1 `f` xn )...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr1</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr1 f = foldr1 f . <a>toNonEmpty</a>
--   </pre>
foldr1 :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr1' :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl1</a>, when applied to a binary
--   operator, and a list, reduces the list using the binary operator, from
--   left to right:
--   
--   <pre>
--   foldl1 f [x1, x2, ..., xn] == (...((x1 `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl1</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl1'</a> instead of <a>foldl1</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>x1 `f`
--   x2</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(`f` x3)</tt>). This results in a thunk chain
--   &lt;math&gt; elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl1 f z = foldl1 f . <a>toNonEmpty</a>
--   </pre>
foldl1 :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <tt>length</tt>).
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl1' f z = foldl1 f . <a>toNonEmpty</a>
--   </pre>
foldl1' :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Insert an <tt>m</tt> between each pair of <tt>t m</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the right, i.e. from right to left.
foldrM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the left, i.e. from left to right.
foldlM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Map variant of <a>foldrM1</a>.
foldrMapM1 :: (Foldable1 t, Monad m) => (a -> m b) -> (a -> b -> m b) -> t a -> m b

-- | Map variant of <a>foldlM1</a>.
foldlMapM1 :: (Foldable1 t, Monad m) => (a -> m b) -> (b -> a -> m b) -> t a -> m b

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximumBy :: Foldable1 t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimumBy :: Foldable1 t => (a -> a -> Ordering) -> t a -> a
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Semigroup.Internal.Alt f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Monoid.Ap f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (GHC.Generics.Rec1 f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (GHC.Generics.M1 i c f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Monad.Trans.Identity.IdentityT f)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Foldable1.JoinWith a)
instance Data.Foldable1.Foldable1 GHC.Base.NonEmpty
instance Data.Foldable1.Foldable1 Data.Ord.Down
instance Data.Foldable1.Foldable1 Data.Complex.Complex
instance Data.Foldable1.Foldable1 ((,) a)
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Dual
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Sum
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Product
instance Data.Foldable1.Foldable1 Data.Semigroup.Min
instance Data.Foldable1.Foldable1 Data.Semigroup.Max
instance Data.Foldable1.Foldable1 Data.Semigroup.First
instance Data.Foldable1.Foldable1 Data.Semigroup.Last
instance Data.Foldable1.Foldable1 GHC.Generics.V1
instance Data.Foldable1.Foldable1 GHC.Generics.Par1
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:+: g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:*: g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:.: g)
instance Data.Foldable1.Foldable1 Data.Functor.Identity.Identity
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Product.Product f g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Sum.Sum f g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Compose.Compose f g)
instance Data.Foldable1.Foldable1 Data.Tree.Tree
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Functor.Reverse.Reverse f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Applicative.Backwards.Backwards f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Applicative.Lift.Lift f)
instance forall k (b :: k). Data.Foldable1.Foldable1 (Data.Tagged.Tagged b)
instance Data.Foldable1.Foldable1 Solo
instance GHC.Base.Semigroup (Data.Foldable1.FromMaybe b)
instance GHC.Base.Semigroup (Data.Foldable1.NonEmptyDList a)
