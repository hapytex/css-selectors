-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A toolkit for making compile-time interpolated templates
--   
--   Shakespeare is a family of type-safe, efficient template languages.
--   Shakespeare templates are expanded at compile-time, ensuring that all
--   interpolated variables are in scope. Variables are interpolated
--   according to their type through a typeclass.
--   
--   Shakespeare templates can be used inline with a quasi-quoter or in an
--   external file.
--   
--   Note there is no dependency on haskell-src-extras. Instead Shakespeare
--   believes logic should stay out of templates and has its own minimal
--   Haskell parser.
--   
--   Packages that use this: xml-hamlet
--   
--   Please see the documentation at
--   <a>http://www.yesodweb.com/book/shakespearean-templates</a> for more
--   details.
@package shakespeare
@version 2.1.0

module Text.Internal.Cassius
i2bMixin :: String -> String


-- | General parsers, functions and datatypes for all Shakespeare
--   languages.
module Text.Shakespeare.Base
data Deref
DerefModulesIdent :: [String] -> Ident -> Deref
DerefIdent :: Ident -> Deref
DerefIntegral :: Integer -> Deref
DerefRational :: Rational -> Deref
DerefString :: String -> Deref
DerefBranch :: Deref -> Deref -> Deref
DerefList :: [Deref] -> Deref
DerefTuple :: [Deref] -> Deref

-- | Record field access via <tt>OverloadedRecordDot</tt>.
--   <a>derefToExp</a> only supports this feature on compilers which
--   support <tt>OverloadedRecordDot</tt>.
DerefGetField :: Deref -> String -> Deref
newtype Ident
Ident :: String -> Ident
type Scope = [(Ident, Exp)]
parseDeref :: UserParser a Deref
parseHash :: UserParser a (Either String Deref)
parseVar :: Char -> UserParser a (Either String Deref)
parseVarString :: Char -> UserParser a (Either String String)
parseAt :: UserParser a (Either String (Deref, Bool))
parseUrl :: Char -> Char -> UserParser a (Either String (Deref, Bool))
parseUrlString :: Char -> Char -> UserParser a (Either String String)
parseCaret :: UserParser a (Either String Deref)
parseUnder :: UserParser a (Either String Deref)
parseInt :: Char -> UserParser a (Either String Deref)
parseIntString :: Char -> UserParser a (Either String String)
derefToExp :: Scope -> Deref -> Exp
flattenDeref :: Deref -> Maybe [String]
readUtf8File :: FilePath -> IO Text

-- | Read file's content as <a>String</a>, converting newlines
readUtf8FileString :: FilePath -> IO String

-- | Embed file's content, converting newlines
readFileQ :: FilePath -> Q String

-- | Embed file's content, converting newlines and track file via ghc
--   dependencies, recompiling on changes
readFileRecompileQ :: FilePath -> Q String
instance Language.Haskell.TH.Syntax.Lift Text.Shakespeare.Base.Ident
instance GHC.Classes.Ord Text.Shakespeare.Base.Ident
instance Data.Data.Data Text.Shakespeare.Base.Ident
instance GHC.Read.Read Text.Shakespeare.Base.Ident
instance GHC.Classes.Eq Text.Shakespeare.Base.Ident
instance GHC.Show.Show Text.Shakespeare.Base.Ident
instance Language.Haskell.TH.Syntax.Lift Text.Shakespeare.Base.Deref
instance GHC.Classes.Ord Text.Shakespeare.Base.Deref
instance Data.Data.Data Text.Shakespeare.Base.Deref
instance GHC.Read.Read Text.Shakespeare.Base.Deref
instance GHC.Classes.Eq Text.Shakespeare.Base.Deref
instance GHC.Show.Show Text.Shakespeare.Base.Deref


-- | future releases.
module Text.Shakespeare
data ShakespeareSettings
ShakespeareSettings :: Char -> Char -> Char -> Exp -> Exp -> Exp -> Bool -> Maybe PreConvert -> Maybe Exp -> ShakespeareSettings
[varChar] :: ShakespeareSettings -> Char
[urlChar] :: ShakespeareSettings -> Char
[intChar] :: ShakespeareSettings -> Char
[toBuilder] :: ShakespeareSettings -> Exp
[wrap] :: ShakespeareSettings -> Exp
[unwrap] :: ShakespeareSettings -> Exp
[justVarInterpolation] :: ShakespeareSettings -> Bool
[preConversion] :: ShakespeareSettings -> Maybe PreConvert

-- | A transformation applied to the final expression. Most often, this
--   would be used to force the type of the expression to help make more
--   meaningful error messages.
[modifyFinalValue] :: ShakespeareSettings -> Maybe Exp

-- | Coffeescript, TypeScript, and other languages compiles down to
--   Javascript. Previously we waited until the very end, at the rendering
--   stage to perform this compilation. Lets call is a post-conversion This
--   had the advantage that all Haskell values were inserted first: for
--   example a value could be inserted that Coffeescript would compile into
--   Javascript. While that is perhaps a safer approach, the advantage is
--   not used in practice: it was that way mainly for ease of
--   implementation. The down-side is the template must be compiled down to
--   Javascript during every request. If instead we do a pre-conversion to
--   compile down to Javascript, we only need to perform the compilation
--   once.
--   
--   The problem then is the insertion of Haskell values: we need a hole
--   for them. This can be done with variables known to the language.
--   During the pre-conversion we first modify all Haskell insertions So
--   #{a} is change to shakespeare_var_a Then we can place the Haskell
--   values in a function wrapper that exposes those variables:
--   (function(shakespeare_var_a){ ... shakespeare_var_a ...}) TypeScript
--   can compile that, and then we tack an application of the Haskell
--   values onto the result: (#{a})
--   
--   preEscapeIgnoreBalanced is used to not insert backtacks for variable
--   already inside strings or backticks. coffeescript will happily ignore
--   the interpolations, and backticks would not be treated as escaping in
--   that context. preEscapeIgnoreLine was added to ignore comments (which
--   in Coffeescript begin with a <tt>#</tt>)
data PreConvert
PreConvert :: PreConversion -> [Char] -> [Char] -> Maybe WrapInsertion -> PreConvert
[preConvert] :: PreConvert -> PreConversion
[preEscapeIgnoreBalanced] :: PreConvert -> [Char]
[preEscapeIgnoreLine] :: PreConvert -> [Char]
[wrapInsertion] :: PreConvert -> Maybe WrapInsertion
data WrapInsertion
WrapInsertion :: Maybe String -> String -> String -> String -> String -> Bool -> WrapInsertion
[wrapInsertionIndent] :: WrapInsertion -> Maybe String
[wrapInsertionStartBegin] :: WrapInsertion -> String
[wrapInsertionSeparator] :: WrapInsertion -> String
[wrapInsertionStartClose] :: WrapInsertion -> String
[wrapInsertionEnd] :: WrapInsertion -> String
[wrapInsertionAddParens] :: WrapInsertion -> Bool
data PreConversion
ReadProcess :: String -> [String] -> PreConversion
Id :: PreConversion
defaultShakespeareSettings :: ShakespeareSettings
shakespeare :: ShakespeareSettings -> QuasiQuoter
shakespeareFile :: ShakespeareSettings -> FilePath -> Q Exp
shakespeareFileReload :: ShakespeareSettings -> FilePath -> Q Exp
shakespeareFromString :: ShakespeareSettings -> String -> Q Exp

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
shakespeareUsedIdentifiers :: ShakespeareSettings -> String -> [(Deref, VarType)]
type RenderUrl url = (url -> QueryParameters -> Text)
data VarType
VTPlain :: VarType
VTUrl :: VarType
VTUrlParam :: VarType
VTMixin :: VarType
data Deref

-- | A parser with a user state of [String]
type Parser = Parsec String [String]
preFilter :: Maybe FilePath -> ShakespeareSettings -> String -> IO String
shakespeareRuntime :: ShakespeareSettings -> FilePath -> [(Deref, VarExp url)] -> Shakespeare url
pack' :: String -> Text
instance Language.Haskell.TH.Syntax.Lift Text.Shakespeare.WrapInsertion
instance Language.Haskell.TH.Syntax.Lift Text.Shakespeare.PreConversion
instance Language.Haskell.TH.Syntax.Lift Text.Shakespeare.PreConvert
instance GHC.Classes.Eq Text.Shakespeare.Content
instance GHC.Show.Show Text.Shakespeare.Content
instance GHC.Generics.Generic Text.Shakespeare.VarType
instance Data.Data.Data Text.Shakespeare.VarType
instance GHC.Enum.Bounded Text.Shakespeare.VarType
instance GHC.Enum.Enum Text.Shakespeare.VarType
instance GHC.Classes.Ord Text.Shakespeare.VarType
instance GHC.Classes.Eq Text.Shakespeare.VarType
instance GHC.Show.Show Text.Shakespeare.VarType
instance Language.Haskell.TH.Syntax.Lift Text.Shakespeare.ShakespeareSettings


-- | A Shakespearean module for Javascript templates, introducing
--   type-safe, compile-time variable and url interpolation.--
--   
--   You might consider trying <a>Typescript</a> or <a>Coffee</a> which
--   compile down to Javascript.
--   
--   Further reading:
--   <a>http://www.yesodweb.com/book/shakespearean-templates</a>
module Text.Julius
js :: QuasiQuoter
julius :: QuasiQuoter
juliusFile :: FilePath -> Q Exp
jsFile :: FilePath -> Q Exp

-- | <i>Deprecated: Please use juliusFileReload instead.</i>
juliusFileDebug :: FilePath -> Q Exp

-- | <i>Deprecated: Please use jsFileReload instead.</i>
jsFileDebug :: FilePath -> Q Exp
juliusFileReload :: FilePath -> Q Exp
jsFileReload :: FilePath -> Q Exp

-- | Return type of template-reading functions.
type JavascriptUrl url = (url -> [(Text, Text)] -> Text) -> Javascript

-- | Newtype wrapper of <a>Builder</a>.
newtype Javascript
Javascript :: Builder -> Javascript
[unJavascript] :: Javascript -> Builder
newtype RawJavascript
RawJavascript :: Builder -> RawJavascript

-- | A typeclass for types that can be interpolated in CoffeeScript
--   templates.
class ToJavascript a
toJavascript :: ToJavascript a => a -> Javascript
class RawJS a
rawJS :: RawJS a => a -> RawJavascript
renderJavascript :: Javascript -> Text

-- | render with route interpolation. If using this module standalone,
--   apart from type-safe routes, a dummy renderer can be used:
--   
--   <pre>
--   renderJavascriptUrl (\_ _ -&gt; undefined) javascriptUrl
--   </pre>
--   
--   When using Yesod, a renderer is generated for you, which can be
--   accessed within the GHandler monad: <a>getUrlRenderParams</a>.
renderJavascriptUrl :: (url -> [(Text, Text)] -> Text) -> JavascriptUrl url -> Text
javascriptSettings :: Q ShakespeareSettings

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
juliusUsedIdentifiers :: String -> [(Deref, VarType)]
asJavascriptUrl :: JavascriptUrl url -> JavascriptUrl url
instance GHC.Base.Monoid Text.Julius.Javascript
instance GHC.Base.Semigroup Text.Julius.Javascript
instance Text.Julius.RawJS [GHC.Types.Char]
instance Text.Julius.RawJS Data.Text.Internal.Text
instance Text.Julius.RawJS Data.Text.Internal.Lazy.Text
instance Text.Julius.RawJS Data.Text.Internal.Builder.Builder
instance Text.Julius.RawJS GHC.Types.Bool
instance Text.Julius.ToJavascript Text.Julius.RawJavascript
instance Text.Julius.ToJavascript GHC.Types.Bool
instance Text.Julius.ToJavascript Data.Aeson.Types.Internal.Value
instance Text.Julius.ToJavascript GHC.Base.String
instance Text.Julius.ToJavascript Data.Text.Internal.Text
instance Text.Julius.ToJavascript Data.Text.Internal.Lazy.Text


-- | A Shakespearean module for Roy, introducing type-safe, compile-time
--   variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>roy</tt>.
--   
--   To use this module, <tt>roy</tt> must be installed on your system.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>roy</tt>, and then the value of the
--   variables are applied to the function. This means that in production
--   the template can be compiled once at compile time and there will be no
--   dependency in your production system on <tt>roy</tt>.
--   
--   Your code:
--   
--   <pre>
--   let b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Final Result:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>https://www.yesodweb.com/book/shakespearean-templates</a></li>
--   <li>Roy: <a>http://roy.brianmckenna.org/</a></li>
--   </ol>
module Text.Roy

-- | Read inline, quasiquoted Roy.
roy :: QuasiQuoter

-- | Read in a Roy template file. This function reads the file once, at
--   compile time.
royFile :: FilePath -> Q Exp

-- | Read in a Roy template file. This impure function uses unsafePerformIO
--   to re-read the file on every call, allowing for rapid iteration.
royFileReload :: FilePath -> Q Exp


-- | A Shakespearean module for CoffeeScript, introducing type-safe,
--   compile-time variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>coffee</tt>.
--   
--   To use this module, <tt>coffee</tt> must be installed on your system.
--   
--   <tt>#{...}</tt> is the Shakespearean standard for variable
--   interpolation, but CoffeeScript already uses that sequence for string
--   interpolation. Therefore, Shakespearean interpolation is introduced
--   with <tt>%{...}</tt>.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>coffee</tt>, and then the value of
--   the variables are applied to the function. This means that in
--   production the template can be compiled once at compile time and there
--   will be no dependency in your production system on <tt>coffee</tt>.
--   
--   Your code:
--   
--   <pre>
--   b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Function wrapper added to your coffeescript code:
--   
--   <pre>
--   ((shakespeare_var_a) =&gt;
--     b = 1
--     console.log(shakespeare_var_a + b)
--   )
--   </pre>
--   
--   This is then compiled down to javascript, and the variables are
--   applied:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>https://www.yesodweb.com/book/shakespearean-templates</a></li>
--   <li>CoffeeScript: <a>http://coffeescript.org/</a></li>
--   </ol>
module Text.Coffee

-- | Read inline, quasiquoted CoffeeScript.
coffee :: QuasiQuoter

-- | Read in a CoffeeScript template file. This function reads the file
--   once, at compile time.
coffeeFile :: FilePath -> Q Exp

-- | Read in a CoffeeScript template file. This impure function uses
--   unsafePerformIO to re-read the file on every call, allowing for rapid
--   iteration.
coffeeFileReload :: FilePath -> Q Exp

-- | Deprecated synonym for <a>coffeeFileReload</a>

-- | <i>Deprecated: Please use coffeeFileReload instead.</i>
coffeeFileDebug :: FilePath -> Q Exp

module Text.Internal.Lucius
luciusWithOrder :: Order -> QuasiQuoter
luciusFromString :: Order -> String -> Q Exp
whiteSpace :: Parser ()
whiteSpace1 :: Parser ()
parseBlock :: Order -> Parser (Block 'Unresolved)

-- | Looks for an &amp; at the beginning of a selector and, if present,
--   indicates that we should not have a leading space. Otherwise, we
--   should have the leading space.
detectAmp :: Block 'Unresolved -> (Bool, Block 'Unresolved)
partitionPBs :: Order -> [PairBlock] -> ([Either (Attr 'Unresolved) Deref], [Block 'Unresolved])
parseSelector :: Parser [Contents]
trim :: Contents -> Contents
data PairBlock
PBAttr :: Attr 'Unresolved -> PairBlock
PBBlock :: Block 'Unresolved -> PairBlock
PBMixin :: Deref -> PairBlock
parsePairsBlocks :: Order -> ([PairBlock] -> [PairBlock]) -> Parser [PairBlock]
parsePair :: Parser (Attr 'Unresolved)
parseContents :: String -> Parser Contents
parseContent :: String -> Parser Content
isHex :: Char -> Bool
atMost :: Int -> Parser a -> Parser [a]
parseComment :: Parser Content
luciusFileWithOrd :: Order -> FilePath -> Q Exp
luciusFileDebugWithOrder :: Order -> FilePath -> Q Exp
parseTopLevels :: Order -> Parser [TopLevel 'Unresolved]
stringCI :: String -> Parser ()
luciusRTWithOrder' :: Order -> Text -> Either String ([(Text, Text)] -> Either String [TopLevel 'Resolved])
luciusRTInternal :: Order -> Text -> Either String ([(Text, RTValue)] -> Either String [TopLevel 'Resolved])
luciusRTWithOrder :: Order -> Text -> [(Text, Text)] -> Either String Text
luciusRTMixinWithOrder :: Order -> Text -> Bool -> [(Text, RTValue)] -> Either String Text
data RTValue
RTVRaw :: Text -> RTValue
RTVMixin :: Mixin -> RTValue
luciusRTMinifiedWithOrder :: Order -> Text -> [(Text, Text)] -> Either String Text

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
luciusUsedIdentifiers :: Order -> String -> [(Deref, VarType)]
luciusMixinWithOrder :: Order -> QuasiQuoter
luciusMixinFromString :: Order -> String -> Q Exp


-- | This module is the twin brother of module Text.Lucius. The difference
--   is that these parsers preserv the given order of attributes and mixin
--   blocks.
--   
--   <pre>
--   let bams = [Text.Ordered.cassiusMixin|
--                 bam1:bam2
--                 ^{bins}
--                 bam3:bam4
--              |] :: Mixin
--       bins = [Text.Ordered.cassiusMixin|
--                 bin1:bin2
--              |] :: Mixin
--    in renderCss ([lucius|foo{bar1:bar2;^{bams};bar3:bar4;}|] undefined)
--   "foo{bar1:bar2;bam1:bam2;bin1:bin2;bam3:bam4;bar3:bar4}"
--   </pre>
module Text.Lucius.Ordered

-- | <pre>
--   &gt;&gt;&gt; renderCss ([lucius|foo{bar:baz}|] undefined)
--   "foo{bar:baz}"
--   </pre>
lucius :: QuasiQuoter

luciusFile :: FilePath -> Q Exp

luciusFileDebug :: FilePath -> Q Exp

luciusFileReload :: FilePath -> Q Exp

luciusMixin :: QuasiQuoter
data Mixin

luciusRT :: Text -> [(Text, Text)] -> Either String Text

luciusRT' :: Text -> Either String ([(Text, Text)] -> Either String [TopLevel 'Resolved])

luciusRTMinified :: Text -> [(Text, Text)] -> Either String Text

luciusRTMixin :: Text -> Bool -> [(Text, RTValue)] -> Either String Text
data RTValue
RTVRaw :: Text -> RTValue
RTVMixin :: Mixin -> RTValue
data Css
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
class ToCss a
toCss :: ToCss a => a -> Builder
renderCss :: Css -> Text
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
data Color
Color :: Word8 -> Word8 -> Word8 -> Color
colorRed :: Color
colorBlack :: Color

-- | Create a CSS size, e.g. $(mkSize "100px").
mkSize :: String -> ExpQ

-- | Absolute size units.
data AbsoluteUnit
Centimeter :: AbsoluteUnit
Inch :: AbsoluteUnit
Millimeter :: AbsoluteUnit
Pica :: AbsoluteUnit
Point :: AbsoluteUnit

-- | Not intended for direct use, see <a>mkSize</a>.
data AbsoluteSize
AbsoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize

-- | Units used for text formatting.
[absoluteSizeUnit] :: AbsoluteSize -> AbsoluteUnit

-- | Normalized value in centimeters.
[absoluteSizeValue] :: AbsoluteSize -> Rational

-- | Constructs <a>AbsoluteSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
absoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize
data EmSize
EmSize :: Rational -> EmSize
data ExSize
ExSize :: Rational -> ExSize

-- | Not intended for direct use, see <a>mkSize</a>.
data PercentageSize
PercentageSize :: Rational -> PercentageSize

-- | Normalized value, 1 == 100%.
[percentageSizeValue] :: PercentageSize -> Rational

-- | Constructs <a>PercentageSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
percentageSize :: Rational -> PercentageSize
data PixelSize
PixelSize :: Rational -> PixelSize
parseTopLevels :: Order -> Parser [TopLevel 'Unresolved]

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
luciusUsedIdentifiers :: Order -> String -> [(Deref, VarType)]

module Text.Lucius

-- | <pre>
--   &gt;&gt;&gt; renderCss ([lucius|foo{bar:baz}|] undefined)
--   "foo{bar:baz}"
--   </pre>
lucius :: QuasiQuoter
luciusFile :: FilePath -> Q Exp
luciusFileDebug :: FilePath -> Q Exp
luciusFileReload :: FilePath -> Q Exp
luciusMixin :: QuasiQuoter
data Mixin
luciusRT :: Text -> [(Text, Text)] -> Either String Text
luciusRT' :: Text -> Either String ([(Text, Text)] -> Either String [TopLevel 'Resolved])

-- | Same as <a>luciusRT</a>, but output has no added whitespace.
--   
--   Since 1.0.3
luciusRTMinified :: Text -> [(Text, Text)] -> Either String Text

-- | Runtime Lucius with mixin support.
--   
--   Since 1.0.6
luciusRTMixin :: Text -> Bool -> [(Text, RTValue)] -> Either String Text
data RTValue
RTVRaw :: Text -> RTValue
RTVMixin :: Mixin -> RTValue
data Css
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
class ToCss a
toCss :: ToCss a => a -> Builder
renderCss :: Css -> Text
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
data Color
Color :: Word8 -> Word8 -> Word8 -> Color
colorRed :: Color
colorBlack :: Color

-- | Create a CSS size, e.g. $(mkSize "100px").
mkSize :: String -> ExpQ

-- | Absolute size units.
data AbsoluteUnit
Centimeter :: AbsoluteUnit
Inch :: AbsoluteUnit
Millimeter :: AbsoluteUnit
Pica :: AbsoluteUnit
Point :: AbsoluteUnit

-- | Not intended for direct use, see <a>mkSize</a>.
data AbsoluteSize
AbsoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize

-- | Units used for text formatting.
[absoluteSizeUnit] :: AbsoluteSize -> AbsoluteUnit

-- | Normalized value in centimeters.
[absoluteSizeValue] :: AbsoluteSize -> Rational

-- | Constructs <a>AbsoluteSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
absoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize
data EmSize
EmSize :: Rational -> EmSize
data ExSize
ExSize :: Rational -> ExSize

-- | Not intended for direct use, see <a>mkSize</a>.
data PercentageSize
PercentageSize :: Rational -> PercentageSize

-- | Normalized value, 1 == 100%.
[percentageSizeValue] :: PercentageSize -> Rational

-- | Constructs <a>PercentageSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
percentageSize :: Rational -> PercentageSize
data PixelSize
PixelSize :: Rational -> PixelSize
parseTopLevels :: Order -> Parser [TopLevel 'Unresolved]

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
luciusUsedIdentifiers :: Order -> String -> [(Deref, VarType)]


-- | Provides functionality for runtime Hamlet templates. Please use
--   <a>Text.Hamlet.Runtime</a> instead.
module Text.Hamlet.RT
newtype HamletRT
HamletRT :: [SimpleDoc] -> HamletRT
data HamletData url
HDHtml :: Html -> HamletData url
HDUrl :: url -> HamletData url
HDUrlParams :: url -> [(Text, Text)] -> HamletData url
HDTemplate :: HamletRT -> HamletData url
HDBool :: Bool -> HamletData url
HDMaybe :: Maybe (HamletMap url) -> HamletData url
HDList :: [HamletMap url] -> HamletData url
type HamletMap url = [([String], HamletData url)]
data HamletException
HamletParseException :: String -> HamletException
HamletUnsupportedDocException :: Doc -> HamletException
HamletRenderException :: String -> HamletException
parseHamletRT :: MonadThrow m => HamletSettings -> String -> m HamletRT
renderHamletRT :: MonadThrow m => HamletRT -> HamletMap url -> UrlRenderer url -> m Html
renderHamletRT' :: MonadThrow m => Bool -> HamletRT -> HamletMap url -> (url -> [(Text, Text)] -> Text) -> m Html
data SimpleDoc
SDRaw :: String -> SimpleDoc
SDVar :: [String] -> SimpleDoc
SDUrl :: Bool -> [String] -> SimpleDoc
SDTemplate :: [String] -> SimpleDoc
SDForall :: [String] -> String -> [SimpleDoc] -> SimpleDoc
SDMaybe :: [String] -> String -> [SimpleDoc] -> [SimpleDoc] -> SimpleDoc
SDCond :: [([String], [SimpleDoc])] -> [SimpleDoc] -> SimpleDoc
instance GHC.Show.Show Text.Hamlet.RT.HamletException
instance GHC.Exception.Type.Exception Text.Hamlet.RT.HamletException

module Text.Hamlet
type Html = Markup

-- | "Simple Hamlet" quasi-quoter. May only be used to generate
--   expressions.
--   
--   Generated expressions have type <a>Html</a>.
--   
--   <pre>
--   &gt;&gt;&gt; <a>putStrLn</a> (<a>renderHtml</a> [<a>shamlet</a>|&lt;div&gt;Hello, world!|])
--   &lt;div&gt;Hello, world!&lt;/div&gt;
--   </pre>
shamlet :: QuasiQuoter
shamletFile :: FilePath -> Q Exp

-- | Like <a>shamlet</a>, but produces XHTML.
xshamlet :: QuasiQuoter

-- | Like <a>shamletFile</a>, but produces XHTML.
xshamletFile :: FilePath -> Q Exp

-- | A function generating an <a>Html</a> given a URL-rendering function.
type HtmlUrl url = Render url -> Html
type Render url = url -> [(Text, Text)] -> Text

-- | Hamlet quasi-quoter. May only be used to generate expressions.
--   
--   Generated expression have type <tt><a>HtmlUrl</a> url</tt>, for some
--   <tt>url</tt>.
--   
--   <pre>
--   data MyRoute = Home
--   
--   render :: <a>Render</a> MyRoute
--   render Home _ = "/home"
--   
--   &gt;&gt;&gt; <a>putStrLn</a> (<a>renderHtml</a> ([<a>hamlet</a>|&lt;a href=@{Home}&gt;Home|] render))
--   &lt;a href="/home"&gt;Home&lt;/a&gt;
--   </pre>
hamlet :: QuasiQuoter
hamletFile :: FilePath -> Q Exp

-- | Like <a>hamletFile</a>, but the external file is parsed at runtime.
--   Allows for more rapid development, but should not be used in
--   production.
hamletFileReload :: FilePath -> Q Exp

-- | Like <a>hamlet</a>, but produces XHTML.
xhamlet :: QuasiQuoter

-- | Like <a>hamletFile</a>, but produces XHTML.
xhamletFile :: FilePath -> Q Exp

-- | A function generating an <a>Html</a> given a message translator and a
--   URL rendering function.
type HtmlUrlI18n msg url = Translate msg -> Render url -> Html
type Translate msg = msg -> Html

-- | Hamlet quasi-quoter with internationalization. May only be used to
--   generate expressions.
--   
--   Generated expressions have type <tt><a>HtmlUrlI18n</a> msg url</tt>,
--   for some <tt>msg</tt> and <tt>url</tt>.
--   
--   <pre>
--   data MyMsg = Hi | Bye
--   
--   data MyRoute = Home
--   
--   renderEnglish :: <a>Translate</a> MyMsg
--   renderEnglish Hi  = "hi"
--   renderEnglish Bye = "bye"
--   
--   renderUrl :: <a>Render</a> MyRoute
--   renderUrl Home _ = "/home"
--   
--   &gt;&gt;&gt; <a>putStrLn</a> (<a>renderHtml</a> ([<a>ihamlet</a>|@{Home} _{Hi} _{Bye}|] renderEnglish renderUrl))
--   &lt;div&gt;/home hi bye &lt;div&gt;
--   </pre>
ihamlet :: QuasiQuoter
ihamletFile :: FilePath -> Q Exp

-- | Like <a>ihamletFile</a>, but the external file is parsed at runtime.
--   Allows for more rapid development, but should not be used in
--   production.
ihamletFileReload :: FilePath -> Q Exp

-- | Convert some value to a list of attribute pairs.
class ToAttributes a
toAttributes :: ToAttributes a => a -> [(Text, Text)]

-- | Settings for parsing of a hamlet document.
data HamletSettings
HamletSettings :: String -> NewlineStyle -> (String -> CloseStyle) -> [(String, String)] -> HamletSettings

-- | The value to replace a "!!!" with. Do not include the trailing
--   newline.
[hamletDoctype] :: HamletSettings -> String

-- | Should we add newlines to the output, making it more human-readable?
--   Useful for client-side debugging but may alter browser page layout.
[hamletNewlines] :: HamletSettings -> NewlineStyle

-- | How a tag should be closed. Use this to switch between HTML, XHTML or
--   even XML output.
[hamletCloseStyle] :: HamletSettings -> String -> CloseStyle

-- | Mapping from short names in "$doctype" statements to full doctype.
[hamletDoctypeNames] :: HamletSettings -> [(String, String)]
data NewlineStyle

-- | never add newlines
NoNewlines :: NewlineStyle

-- | add newlines between consecutive text lines
NewlinesText :: NewlineStyle

-- | add newlines everywhere
AlwaysNewlines :: NewlineStyle
DefaultNewlineStyle :: NewlineStyle
hamletWithSettings :: Q HamletRules -> HamletSettings -> QuasiQuoter
hamletFileWithSettings :: Q HamletRules -> HamletSettings -> FilePath -> Q Exp

-- | Defaults settings: HTML5 doctype and HTML-style empty tags.
defaultHamletSettings :: HamletSettings
xhtmlHamletSettings :: HamletSettings
data Env
Env :: Maybe ((Exp -> Q Exp) -> Q Exp) -> Maybe ((Exp -> Q Exp) -> Q Exp) -> Env
[urlRender] :: Env -> Maybe ((Exp -> Q Exp) -> Q Exp)
[msgRender] :: Env -> Maybe ((Exp -> Q Exp) -> Q Exp)
data HamletRules
HamletRules :: Exp -> ((Env -> Q Exp) -> Q Exp) -> (Env -> Exp -> Q Exp) -> HamletRules
[hrFromHtml] :: HamletRules -> Exp
[hrWithEnv] :: HamletRules -> (Env -> Q Exp) -> Q Exp
[hrEmbed] :: HamletRules -> Env -> Exp -> Q Exp
hamletRules :: Q HamletRules
ihamletRules :: Q HamletRules
htmlRules :: Q HamletRules
data CloseStyle
NoClose :: CloseStyle
CloseInside :: CloseStyle
CloseSeparate :: CloseStyle

-- | Checks for truth in the left value in each pair in the first argument.
--   If a true exists, then the corresponding right action is performed.
--   Only the first is performed. In there are no true values, then the
--   second argument is performed, if supplied.
condH :: Monad m => [(Bool, m ())] -> Maybe (m ()) -> m ()

-- | Runs the second argument with the value in the first, if available.
--   Otherwise, runs the third argument, if available.
maybeH :: Monad m => Maybe v -> (v -> m ()) -> Maybe (m ()) -> m ()
asHtmlUrl :: HtmlUrl url -> HtmlUrl url
attrsToHtml :: [(Text, Text)] -> Html
hamletFromString :: Q HamletRules -> HamletSettings -> String -> Q Exp
instance GHC.Show.Show (Text.Hamlet.VarExp msg url)
instance Text.Hamlet.ToAttributes (Data.Text.Internal.Text, Data.Text.Internal.Text)
instance Text.Hamlet.ToAttributes (GHC.Base.String, GHC.Base.String)
instance Text.Hamlet.ToAttributes [(Data.Text.Internal.Text, Data.Text.Internal.Text)]
instance Text.Hamlet.ToAttributes [(GHC.Base.String, GHC.Base.String)]


-- | Module for parsing and rendering Hamlet templates at runtime, not
--   compile time. This uses the same Hamlet parsing as compile-time
--   Hamlet, but has some limitations, such as:
--   
--   <ul>
--   <li>No compile-time checking of validity</li>
--   <li>Can't apply functions at runtime</li>
--   <li>No URL rendering</li>
--   </ul>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Text.Hamlet.Runtime
--   import qualified Data.Map as Map
--   import Text.Blaze.Html.Renderer.String (renderHtml)
--   
--   main :: IO ()
--   main = do
--       template &lt;- parseHamletTemplate defaultHamletSettings $ unlines
--           [ "&lt;p&gt;Hello, #{name}"
--           , "$if hungry"
--           , "  &lt;p&gt;Available food:"
--           , "  &lt;ul&gt;"
--           , "    $forall food &lt;- foods"
--           , "      &lt;li&gt;#{food}"
--           ]
--       let hamletDataMap = Map.fromList
--               [ ("name", "Michael")
--               , ("hungry", toHamletData True) -- always True
--               , ("foods", toHamletData
--                   [ "Apples"
--                   , "Bananas"
--                   , "Carrots"
--                   ])
--               ]
--       html &lt;- renderHamletTemplate template hamletDataMap
--       putStrLn $ renderHtml html
--   </pre>
module Text.Hamlet.Runtime

-- | A parsed Hamlet template. See <a>parseHamletTemplate</a> and
--   <a>readHamletTemplateFile</a>.
data HamletTemplate

-- | Settings for parsing of a hamlet document.
data HamletSettings

-- | Defaults settings: HTML5 doctype and HTML-style empty tags.
defaultHamletSettings :: HamletSettings

-- | A piece of data that can be embedded and passed to a Hamlet template
--   (via <a>renderHamletTemplate</a>).
--   
--   This supplies an <a>IsString</a> instance, so with
--   <tt>OverloadedStrings</tt> it will support literal strings, which are
--   converted to HTML via <a>toHtml</a>. For other datatypes, use
--   <a>toHamletData</a>.
data HamletData

-- | Data which can be passed to a Hamlet template.
class ToHamletData a
toHamletData :: ToHamletData a => a -> HamletData

-- | Parse an in-memory Hamlet template. This operation may fail if the
--   template is not parsable.
parseHamletTemplate :: MonadThrow m => HamletSettings -> String -> m HamletTemplate

-- | Same as <a>parseHamletTemplate</a>, but reads from a file. The file is
--   assumed to be UTF-8 encoded (same assumption as compile-time Hamlet).
readHamletTemplateFile :: (MonadThrow m, MonadIO m) => HamletSettings -> FilePath -> m HamletTemplate

-- | Render a runtime Hamlet template, together with a <a>Map</a> of
--   variables to pass in, into an <a>Html</a> value. This can fail if the
--   template references a variable that is not present in the
--   <tt>Map</tt>.
renderHamletTemplate :: MonadThrow m => HamletTemplate -> Map Text HamletData -> m Html
instance Text.Hamlet.Runtime.ToHamletData Text.Hamlet.Runtime.HamletData
instance (a GHC.Types.~ Text.Hamlet.Runtime.HamletData) => Text.Hamlet.Runtime.ToHamletData [a]
instance (a GHC.Types.~ Text.Hamlet.Runtime.HamletData) => Text.Hamlet.Runtime.ToHamletData (GHC.Maybe.Maybe a)
instance Text.Hamlet.Runtime.ToHamletData Data.Text.Internal.Text
instance Text.Hamlet.Runtime.ToHamletData Text.Blaze.Html.Html
instance Text.Hamlet.Runtime.ToHamletData GHC.Types.Bool
instance Data.String.IsString Text.Hamlet.Runtime.HamletData


-- | This module is the twin brother of module Text.Cassius. The difference
--   is that these parsers preserv the given order of attributes and mixin
--   blocks.
--   
--   <pre>
--   let bams = [cassiusMixin|
--                 bam1:bam2
--                 ^{bins}
--                 bam3:bam4
--              |] :: Mixin
--       bins = [cassiusMixin|
--                 bin1:bin2
--              |] :: Mixin
--    in renderCss ([Text.Ordered.lucius|foo{bar1:bar2;^{bams};bar3:bar4;}|] undefined)
--   "foo{bar1:bar2;bam1:bam2;bin1:bin2;bam3:bam4;bar3:bar4}"
--   </pre>
module Text.Cassius.Ordered
data Css
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
class ToCss a
toCss :: ToCss a => a -> Builder
renderCss :: Css -> Text
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text

cassius :: QuasiQuoter

cassiusFile :: FilePath -> Q Exp

cassiusFileDebug :: FilePath -> Q Exp

cassiusFileReload :: FilePath -> Q Exp

-- | Create a mixin with Cassius syntax.
--   
--   | @since 2.0.30
cassiusMixin :: QuasiQuoter
data Mixin
data Color
Color :: Word8 -> Word8 -> Word8 -> Color
colorRed :: Color
colorBlack :: Color

-- | Create a CSS size, e.g. $(mkSize "100px").
mkSize :: String -> ExpQ

-- | Absolute size units.
data AbsoluteUnit
Centimeter :: AbsoluteUnit
Inch :: AbsoluteUnit
Millimeter :: AbsoluteUnit
Pica :: AbsoluteUnit
Point :: AbsoluteUnit

-- | Not intended for direct use, see <a>mkSize</a>.
data AbsoluteSize
AbsoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize

-- | Units used for text formatting.
[absoluteSizeUnit] :: AbsoluteSize -> AbsoluteUnit

-- | Normalized value in centimeters.
[absoluteSizeValue] :: AbsoluteSize -> Rational

-- | Constructs <a>AbsoluteSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
absoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize
data EmSize
EmSize :: Rational -> EmSize
data ExSize
ExSize :: Rational -> ExSize

-- | Not intended for direct use, see <a>mkSize</a>.
data PercentageSize
PercentageSize :: Rational -> PercentageSize

-- | Normalized value, 1 == 100%.
[percentageSizeValue] :: PercentageSize -> Rational

-- | Constructs <a>PercentageSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
percentageSize :: Rational -> PercentageSize
data PixelSize
PixelSize :: Rational -> PixelSize

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel. | @since 2.0.30
cassiusUsedIdentifiers :: String -> [(Deref, VarType)]

module Text.Cassius
data Css
type CssUrl url = (url -> [(Text, Text)] -> Text) -> Css
class ToCss a
toCss :: ToCss a => a -> Builder
renderCss :: Css -> Text
renderCssUrl :: (url -> [(Text, Text)] -> Text) -> CssUrl url -> Text
cassius :: QuasiQuoter
cassiusFile :: FilePath -> Q Exp
cassiusFileDebug :: FilePath -> Q Exp
cassiusFileReload :: FilePath -> Q Exp

-- | Create a mixin with Cassius syntax.
--   
--   Since 2.0.3
cassiusMixin :: QuasiQuoter
data Mixin
data Color
Color :: Word8 -> Word8 -> Word8 -> Color
colorRed :: Color
colorBlack :: Color

-- | Create a CSS size, e.g. $(mkSize "100px").
mkSize :: String -> ExpQ

-- | Absolute size units.
data AbsoluteUnit
Centimeter :: AbsoluteUnit
Inch :: AbsoluteUnit
Millimeter :: AbsoluteUnit
Pica :: AbsoluteUnit
Point :: AbsoluteUnit

-- | Not intended for direct use, see <a>mkSize</a>.
data AbsoluteSize
AbsoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize

-- | Units used for text formatting.
[absoluteSizeUnit] :: AbsoluteSize -> AbsoluteUnit

-- | Normalized value in centimeters.
[absoluteSizeValue] :: AbsoluteSize -> Rational

-- | Constructs <a>AbsoluteSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
absoluteSize :: AbsoluteUnit -> Rational -> AbsoluteSize
data EmSize
EmSize :: Rational -> EmSize
data ExSize
ExSize :: Rational -> ExSize

-- | Not intended for direct use, see <a>mkSize</a>.
data PercentageSize
PercentageSize :: Rational -> PercentageSize

-- | Normalized value, 1 == 100%.
[percentageSizeValue] :: PercentageSize -> Rational

-- | Constructs <a>PercentageSize</a>. Not intended for direct use, see
--   <a>mkSize</a>.
percentageSize :: Rational -> PercentageSize
data PixelSize
PixelSize :: Rational -> PixelSize

-- | Determine which identifiers are used by the given template, useful for
--   creating systems like yesod devel.
cassiusUsedIdentifiers :: String -> [(Deref, VarType)]


-- | This module provides a type-based system for providing translations
--   for text strings.
--   
--   It is similar in purpose to gettext or Java message bundles.
--   
--   The core idea is to create simple data type where each constructor
--   represents a phrase, sentence, paragraph, etc. For example:
--   
--   <pre>
--   data AppMessages = Hello | Goodbye
--   </pre>
--   
--   The <a>RenderMessage</a> class is used to retrieve the appropriate
--   translation for a message value:
--   
--   <pre>
--   class RenderMessage master message where
--     renderMessage :: master  -- ^ type that specifies which set of translations to use
--                   -&gt; [Lang]  -- ^ acceptable languages in descending order of preference
--                   -&gt; message -- ^ message to translate
--                   -&gt; Text
--   </pre>
--   
--   Defining the translation type and providing the <a>RenderMessage</a>
--   instance in Haskell is not very translator friendly. Instead,
--   translations are generally provided in external translations files.
--   Then the <a>mkMessage</a> Template Haskell function is used to read
--   the external translation files and automatically create the
--   translation type and the <tt>RenderMessage</tt> instance.
--   
--   A full description of using this module to create translations for
--   <tt>Hamlet</tt> can be found here:
--   
--   <a>http://www.yesodweb.com/book/internationalization</a>
--   
--   A full description of using the module to create translations for
--   <tt>HSP</tt> can be found here:
--   
--   <a>http://happstack.com/docs/crashcourse/Templates.html#hsp-i18n</a>
--   
--   You can also adapt those instructions for use with other systems.
module Text.Shakespeare.I18N

-- | generate translations from translation files
--   
--   This function will:
--   
--   <ol>
--   <li>look in the supplied subdirectory for files ending in
--   <tt>.msg</tt></li>
--   <li>generate a type based on the constructors found</li>
--   <li>create a <a>RenderMessage</a> instance</li>
--   </ol>
mkMessage :: String -> FilePath -> Lang -> Q [Dec]

-- | create <a>RenderMessage</a> instance for an existing data-type
mkMessageFor :: String -> String -> FilePath -> Lang -> Q [Dec]

-- | create an additional set of translations for a type created by
--   <a>mkMessage</a>
mkMessageVariant :: String -> String -> FilePath -> Lang -> Q [Dec]

-- | the <a>RenderMessage</a> is used to provide translations for a message
--   types
--   
--   The <tt>master</tt> argument exists so that it is possible to provide
--   more than one set of translations for a <tt>message</tt> type. This is
--   useful if a library provides a default set of translations, but the
--   user of the library wants to provide a different set of translations.
class RenderMessage master message
renderMessage :: RenderMessage master message => master -> [Lang] -> message -> Text

-- | <a>ToMessage</a> is used to convert the value inside #{ } to
--   <a>Text</a>
--   
--   The primary purpose of this class is to allow the value in #{ } to be
--   a <a>String</a> or <a>Text</a> rather than forcing it to always be
--   <a>Text</a>.
class ToMessage a
toMessage :: ToMessage a => a -> Text
data SomeMessage master
SomeMessage :: msg -> SomeMessage master

-- | an RFC1766 / ISO 639-1 language code (eg, <tt>fr</tt>, <tt>en-GB</tt>,
--   etc).
type Lang = Text
instance Data.String.IsString (Text.Shakespeare.I18N.SomeMessage master)
instance (master GHC.Types.~ master') => Text.Shakespeare.I18N.RenderMessage master (Text.Shakespeare.I18N.SomeMessage master')
instance Text.Shakespeare.I18N.RenderMessage master Data.Text.Internal.Text
instance Text.Shakespeare.I18N.ToMessage Data.Text.Internal.Text
instance Text.Shakespeare.I18N.ToMessage GHC.Base.String


-- | A Shakespearean module for general text processing, introducing
--   type-safe, compile-time variable interpolation.
--   
--   Text templates use the same parser as for other shakespearean
--   templates which enables variable interpolation using <tt>#{..}</tt>.
--   The parser also recognize the @<tt>{..}</tt> and <tt>^{..}</tt>
--   syntax.
--   
--   If it is necessary that your template produces the output containing
--   one of the interpolation syntax you can escape the sequence using a
--   backslash:
--   
--   <pre>
--   λ&gt; :set -XQuasiQuotes
--   λ&gt; let bar = 23 :: Int in [st|#{bar}|] :: Text
--   </pre>
--   
--   produces "23", but
--   
--   <pre>
--   λ&gt; let bar = 23 :: Int in [st|#\{bar}|] :: Text
--   </pre>
--   
--   returns "#{bar}". The escaping backslash is removed from the output.
--   
--   Further reading: Shakespearean templates:
--   <a>https://www.yesodweb.com/book/shakespearean-templates</a>
module Text.Shakespeare.Text
type TextUrl url = RenderUrl url -> Builder
class ToText a
toText :: ToText a => a -> Builder
renderTextUrl :: RenderUrl url -> TextUrl url -> Text

-- | "Simple text" quasi-quoter. May only be used to generate expressions.
--   
--   Generated expressions have type <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; do let x = "world"
--          <a>putStrLn</a> [<a>stext</a>|Hello, #{x}!|]
--   Hello, world!
--   </pre>
stext :: QuasiQuoter

-- | Like <a>stext</a>, but reads an external file at compile-time.
stextFile :: FilePath -> Q Exp
text :: QuasiQuoter
textFile :: FilePath -> Q Exp

-- | <i>Deprecated: Please use textFileReload instead</i>
textFileDebug :: FilePath -> Q Exp
textFileReload :: FilePath -> Q Exp
st :: QuasiQuoter
lt :: QuasiQuoter
sbt :: QuasiQuoter
lbt :: QuasiQuoter

-- | codegen is designed for generating Yesod code, including templates So
--   it uses different interpolation characters that won't clash with
--   templates. You can use the normal text quasiquoters to generate code
codegen :: QuasiQuoter

-- | Generates strict Text codegen is designed for generating Yesod code,
--   including templates So it uses different interpolation characters that
--   won't clash with templates.
codegenSt :: QuasiQuoter
codegenFile :: FilePath -> Q Exp
codegenFileReload :: FilePath -> Q Exp
instance Text.Shakespeare.Text.ToText Data.Text.Internal.Builder.Builder
instance Text.Shakespeare.Text.ToText [GHC.Types.Char]
instance Text.Shakespeare.Text.ToText Data.Text.Internal.Text
instance Text.Shakespeare.Text.ToText Data.Text.Internal.Lazy.Text
instance Text.Shakespeare.Text.ToText GHC.Int.Int32
instance Text.Shakespeare.Text.ToText GHC.Int.Int64
instance Text.Shakespeare.Text.ToText GHC.Types.Int


-- | A Shakespearean module for TypeScript, introducing type-safe,
--   compile-time variable and url interpolation. It is exactly the same as
--   <a>Text.Julius</a>, except that the template is first compiled to
--   Javascript with the system tool <tt>tsc</tt>.
--   
--   To use this module, <tt>tsc</tt> must be installed on your system.
--   
--   If you interpolate variables, the template is first wrapped with a
--   function containing javascript variables representing shakespeare
--   variables, then compiled with <tt>tsc</tt>, and then the value of the
--   variables are applied to the function. This means that in production
--   the template can be compiled once at compile time and there will be no
--   dependency in your production system on <tt>tsc</tt>.
--   
--   Your code:
--   
--   <pre>
--   var b = 1
--   console.log(#{a} + b)
--   </pre>
--   
--   Final Result:
--   
--   <pre>
--   ;(function(shakespeare_var_a){
--     var b = 1;
--     console.log(shakespeare_var_a + b);
--   })(#{a});
--   </pre>
--   
--   Important Warnings! This integration is not ideal.
--   
--   Due to the function wrapper, all type declarations must be in separate
--   .d.ts files. However, if you don't interpolate variables, no function
--   wrapper will be created, and you can make type declarations in the
--   same file.
--   
--   This does not work cross-platform!
--   
--   Unfortunately tsc does not support stdin and stdout. So a hack of
--   writing to temporary files using the mktemp command is used. This
--   works on my version of Linux, but not for windows unless perhaps you
--   install a mktemp utility, which I have not tested. Please vote up this
--   bug: <a>http://typescript.codeplex.com/workitem/600</a>
--   
--   Making this work on Windows would not be very difficult, it will just
--   require a new package with a dependency on a package like temporary.
--   
--   Further reading:
--   
--   <ol>
--   <li>Shakespearean templates:
--   <a>https://www.yesodweb.com/book/shakespearean-templates</a></li>
--   <li>TypeScript: <a>https://www.typescriptlang.org/</a></li>
--   </ol>
module Text.TypeScript

-- | Read inline, quasiquoted TypeScript
tsc :: QuasiQuoter

-- | Read inline, quasiquoted TypeScript with jsx
tscJSX :: QuasiQuoter

-- | Read in a TypeScript template file. This function reads the file once,
--   at compile time.
typeScriptFile :: FilePath -> Q Exp

-- | Read in a TypeScript template file with jsx. This function reads the
--   file once, at compile time.
typeScriptJSXFile :: FilePath -> Q Exp

-- | Read in a TypeScript template file. This impure function uses
--   unsafePerformIO to re-read the file on every call, allowing for rapid
--   iteration.
typeScriptFileReload :: FilePath -> Q Exp

-- | Read in a TypeScript with jsx template file. This impure function uses
--   unsafePerformIO to re-read the file on every call, allowing for rapid
--   iteration.
typeScriptJSXFileReload :: FilePath -> Q Exp
